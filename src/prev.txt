 if (processing) {
    await sendMessage(req, Message.PROCESSING_MESSAAGE);
    return res.status(200).json({ success: true });
  }

  if (!req.body || !req.body.message) {
    await sendMessage(req, Message.ERROR_MESSAGE);
    return res.status(200).send("Something went wrong");
  }

  if (
    req.body.message.caption &&
    req.body.message.caption == "/pdf" &&
    req.body.message.document &&
    req.body.message.document.mime_type === "application/pdf"
  ) {
    try {
      processing = true;
      await sendMessage(req, Message.URL_PROCESSING_MESSAGE);
      const fileLink = await getFileLink(req.body.message.document.file_id);
      const document = await getDocumentPdf(fileLink);

      for (const { url, body } of document) {
        const id = nanoid();
        const input = body.replace(/\n/g, " ");

        console.log("\nDocument length: \n", body.length);
        console.log("\nURL: \n", url);

        const embeddingResponse = await openAi.createEmbedding({
          model: "text-embedding-ada-002",
          input,
        });

        const [{ embedding }] = await embeddingResponse.data.data;

        // Store the emedding in Postgres db.
        await supabaseClient.from("documents").insert({
          content: input,
          embedding,
          url,
        });
      }

      await sendMessage(req, "Processed");
    } catch (err) {
      console.log(err);
    } finally {
      processing = false;
      return res.status(200).send("OK");
    }
  }

  if (req.body.message.text === "/start") {
    await sendMessage(req, Message.WELCOME_MESSAGE);
    return res.status(200).json({ success: true });
  }

  if (req.body.message.text === "/dt") {
    const { data: urls, error } = await supabaseClient
      .from("distinct_urls")
      .select();

    if (error) {
      await sendMessage(req, "Something went wrong try again later.");
    } else {
      const urlStrings = urls.map((url) => "%0A <i>" + url.url + "</i>");
      const urlString =
        "I am currenly trained on the following datasets:" +
        urlStrings.join("\n");
      console.log(urlString);
      await sendMessage(req, urlString);
    }

    return res.status(200).json({ success: true });
  }

  if (req.body.message.text && req.body.message.text.endsWith("?")) {
    try {
      await sendChatAction(req);
      const input = req.body.message.text.replace(/\n/g, " ");

      const embeddingResponse = await fetch(
        "https://api.openai.com/v1/embeddings",
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            input,
            model: "text-embedding-ada-002",
          }),
        }
      );

      const embeddingData = await embeddingResponse.json();
      const [{ embedding }] = embeddingData.data;

      // In production we should handle possible errors
      const { data: documents, error } = await supabaseClient.rpc(
        "match_documents",
        {
          query_embedding: embedding,
          similarity_threshold: 0.1,
          match_count: 10,
        }
      );

      if (error) {
        console.error(error);
        await sendMessage(req, "Nothing found. Please change your question. ");
        return res.status(200).json({ error: error });
      } else {
        console.log(documents);
      }

      const tokenizer = new GPT3Tokenizer({ type: "gpt3" });
      let tokenCount = 0;
      let contextText = "";

      // console.log("documents: ", documents);

      // Concat matched documents
      if (documents) {
        for (let i = 0; i < documents.length; i++) {
          const document = documents[i];
          const content = document.content;
          const url = document.url;
          const encoded = tokenizer.encode(content);
          tokenCount += encoded.text.length;

          // Limit context to max 1500 tokens (configurable)
          if (tokenCount > 1500) {
            break;
          }

          contextText += `${content.trim()}\nSOURCE: ${url}\n---\n`;
        }
      }

      const prompt = `\
    You are a helpful assistant. When given CONTEXT you answer questions using only that information,
    and you always format your output in markdown. You include code snippets if relevant. If you are unsure and the answer
    is not explicitly written in the CONTEXT provided, you say
    "Sorry, I don't know how to help with that." If the CONTEXT includes 
    source URLs include them under a SOURCES heading at the end of your response. Always include all of the relevant source urls 
    from the CONTEXT, but never list a URL more than once (ignore trailing forward slashes when comparing for uniqueness). Never include URLs that are not in the CONTEXT sections. Never make up URLs

CONTEXT:
${contextText}

QUESTION: """
${input}
"""`;

      // In production we should handle possible errors
      const completionResponse = await openAi.createCompletion({
        model: "text-davinci-003",
        prompt,
        max_tokens: 512, // Choose the max allowed tokens in completion
        temperature: 0, // Set to 0 for deterministic results
      });

      const {
        id,
        choices: [{ text }],
      } = completionResponse.data;

      await sendMessage(req, text as string);
    } catch (err) {
      await sendMessage(req, "Sorry, I don't know how to help with that.");
    } finally {
      return res.status(200).json({ success: true });
    }
  }

  if (req.body.message.text === "/help") {
    await sendMessage(req, Message.HELP_MESSAGE);
    return res.status(200).json({ success: true });
  }

  if (req.body.message.text && req.body.message.text.startsWith("/url")) {
    await sendMessage(req, Message.PREMIUM_MESSAGE);
    return res.status(200).json({ success: true });
    const url = parseTelegramMessage(req.body.message.text);
    const isValid = await isValidUrl(url || "");

    if (isValid) {
      processing = true;
      await sendMessage(req, Message.URL_PROCESSING_MESSAGE);
      const document = await getDocument(url as string);

      for (const { url, body } of document) {
        const id = nanoid();
        const input = body.replace(/\n/g, " ");

        console.log("\nDocument length: \n", body.length);
        console.log("\nURL: \n", url);

        const embeddingResponse = await openAi.createEmbedding({
          model: "text-embedding-ada-002",
          input,
        });

        const [{ embedding }] = await embeddingResponse.data.data;

        // Store the emedding in Postgres db.
        await supabaseClient.from("documents").insert({
          content: input,
          embedding,
          url,
        });
      }

      processing = false;
      await sendMessage(req, "Processed");
      return res.status(200).json({ success: true });
    } else {
      await sendMessage(req, Message.INVALID_URL_MESSAGE);
    }

    await sendMessage(req, Message.HELP_SUGGESTION);
    return res.status(200).json({ success: true });
  }

  await sendMessage(
    req,
    "Please type /help to get a list of all available commands."
  );
  return res.status(200).json({ success: true });
};
